var documenterSearchIndex = {"docs":
[{"location":"examples/metal_2d_image_eval/#Metal-2D-Foundry:-Evaluate-Objective-from-an-Image","page":"Metal 2D Image Evaluation","title":"Metal 2D Foundry: Evaluate Objective from an Image","text":"\n\n@meta EditURL = \"https://github.com/ianmatthewhammond/DistributedEmitterOpt.jl/tree/main/docs/src/examples/metal2dimage_eval.jl\"\n\n\n\nThis example evaluates the SERS objective for a fixed metal design specified by a grayscale image (metal = 1, void = 0). No optimization is performed.\n\nusing DistributedEmitterOpt\nusing LinearAlgebra\n\nOptional (if you want to load an image): using FileIO, ImageIO, ImageTransformations, ColorTypes","category":"section"},{"location":"examples/metal_2d_image_eval/#1.-Mesh-simulation-(foundry-mode)","page":"Metal 2D Image Evaluation","title":"1. Mesh + simulation (foundry mode)","text":"λ = 532.0\ngeo = SymmetricGeometry(λ; L=200.0, W=200.0, hd=120.0, hsub=60.0)\ngeo.l1 = 40.0\ngeo.l2 = 20.0\ngeo.l3 = 40.0\n\noutdir = mktempdir()\nmeshfile = joinpath(outdir, \"mesh.msh\")\ngenmesh(geo, meshfile; per_x=true, per_y=true)\n\nsim = build_simulation(meshfile; foundry_mode=true, dir_x=false, dir_y=false)","category":"section"},{"location":"examples/metal_2d_image_eval/#2.-Physics-objective-(elastic,-isotropic)","page":"Metal 2D Image Evaluation","title":"2. Physics + objective (elastic, isotropic)","text":"env = Environment(mat_design=\"Ag\", mat_substrate=\"Ag\", mat_fluid=1.33)\ninputs = [FieldConfig(λ; θ=0.0, pol=:y)]\n\nEmpty outputs => elastic scattering\n\npde = MaxwellProblem(env=env, inputs=inputs, outputs=FieldConfig[])\n\nobjective = SERSObjective(\n    αₚ=Matrix{ComplexF64}(I, 3, 3),\n    volume=true,\n    surface=false,\n    use_damage_model=false\n)\n\ncontrol = Control(\n    use_filter=true,\n    R_filter=(20.0, 20.0, 20.0),\n    use_dct=true,  # DCT filtering for 2D foundry mode\n    use_projection=true,\n    β=8.0,\n    η=0.5,\n    use_ssp=true\n)\n\nprob = OptimizationProblem(pde, objective, sim, UmfpackSolver();\n    foundry_mode=true,\n    control=control,\n    root=outdir\n)","category":"section"},{"location":"examples/metal_2d_image_eval/#3.-Load-design-from-image-(grayscale)","page":"Metal 2D Image Evaluation","title":"3. Load design from image (grayscale)","text":"The image should be normalized so 1.0 = metal, 0.0 = void.\n\nimg = load(\"design.png\") imggray = channelview(colorview(Gray, img)) imgresized = imresize(imggray, (length(sim.grid.x), length(sim.grid.y))) pimg = clamp.(Float64.(img_resized), 0.0, 1.0)\n\nIf your image uses white=void, invert it: pimg = 1 .- pimg\n\nIf the pattern looks transposed or flipped, try: pimg = reverse(permutedims(pimg), dims=2)\n\nPlaceholder: simple radial pattern (replace with image data)\n\nnx, ny = length(sim.grid.x), length(sim.grid.y)\nx = range(-1.0, 1.0, length=nx)\ny = range(-1.0, 1.0, length=ny)\np_img = [sqrt(xi^2 + yj^2) < 0.4 ? 1.0 : 0.0 for xi in x, yj in y]","category":"section"},{"location":"examples/metal_2d_image_eval/#4.-Evaluate-objective-(no-optimization)","page":"Metal 2D Image Evaluation","title":"4. Evaluate objective (no optimization)","text":"prob.p .= vec(p_img)\n\nEvaluate objective + gradient (If you only need g, pass an empty gradient vector to objectiveandgradient!)\n\ng, ∇g = evaluate(prob, prob.p)\n\nprintln(\"Objective value = \", g)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"api/types/#Types","page":"Types","title":"Types","text":"Core data structures for problem definition and state management.","category":"section"},{"location":"api/types/#Problem-Definition","page":"Types","title":"Problem Definition","text":"","category":"section"},{"location":"api/types/#ObjectiveFunction-Interface","page":"Types","title":"ObjectiveFunction Interface","text":"","category":"section"},{"location":"api/types/#Optimization-Problem","page":"Types","title":"Optimization Problem","text":"The main entry point. Use the meshfile-based constructor for most cases:\n\nprob = OptimizationProblem(pde, objective, meshfile, solver; per_x, per_y, foundry_mode, control)\n\nThis automatically creates a SimulationBundle with simulations for both x and y polarizations.","category":"section"},{"location":"api/types/#Simulation-Infrastructure","page":"Types","title":"Simulation Infrastructure","text":"A Simulation holds the FEM infrastructure (spaces, measures, mesh). A SimulationBundle groups simulations by polarization for mixed-polarization problems.","category":"section"},{"location":"api/types/#Solver-Caches","page":"Types","title":"Solver Caches","text":"Caches for LU factorizations, keyed by wavelength. SolverPoolBundle mirrors SimulationBundle for polarization-aware caching.","category":"section"},{"location":"api/types/#Foundry-Grid-(2D-DOF-Mode)","page":"Types","title":"Foundry Grid (2D DOF Mode)","text":"","category":"section"},{"location":"api/types/#Control-Parameters","page":"Types","title":"Control Parameters","text":"","category":"section"},{"location":"api/types/#DistributedEmitterOpt.FieldConfig","page":"Types","title":"DistributedEmitterOpt.FieldConfig","text":"FieldConfig\n\nConfiguration for a single field solve (frequency, angle, polarization).\n\n\n\n\n\n","category":"type"},{"location":"api/types/#DistributedEmitterOpt.Environment","page":"Types","title":"DistributedEmitterOpt.Environment","text":"Environment(; mat_design, mat_substrate=mat_design, mat_fluid=sqrt(1.77))\n\nFields\n\nmat_design — Design region material (typically metal)\nmat_substrate — Substrate material (defaults to mat_design)\nmat_fluid — Fluid/background material (default √1.77)\nlogger_cfg — Runtime logging config (default off)\n\n\n\n\n\n","category":"type"},{"location":"api/types/#DistributedEmitterOpt.MaxwellProblem","page":"Types","title":"DistributedEmitterOpt.MaxwellProblem","text":"MaxwellProblem\n\nPDE definition for Maxwell curl-curl equation. Specifies the physical environment, input/output field configurations, and solver parameters.\n\nThis type describes WHAT to solve (environment + configs), not HOW to solve (that's in simulation + caches).\n\n\n\n\n\n","category":"type"},{"location":"api/types/#DistributedEmitterOpt.ObjectiveFunction","page":"Types","title":"DistributedEmitterOpt.ObjectiveFunction","text":"ObjectiveFunction\n\nAbstract type for optimization objectives. Implementations define how to compute the objective value and gradients from field solutions.\n\nRequired interface\n\ncompute_objective(obj, pde, fields, pt, sim) — Objective value g\ncompute_adjoint_sources(obj, pde, fields, pt, sim) — ∂g/∂E for each field\nexplicit_sensitivity(obj, pde, fields, pf, pt, sim, control) — Explicit ∂g/∂pf\n\nFields is a Dict{CacheKey, CellField} mapping (λ, θ, pol) → E. pde provides the input/output FieldConfig lists and weights.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#DistributedEmitterOpt.compute_objective","page":"Types","title":"DistributedEmitterOpt.compute_objective","text":"compute_objective(obj::SERSObjective, pde, fields, pt, sim) → Float64\n\nCompute SERS objective using trace formula. Sums over all input/output combinations with their weights.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#DistributedEmitterOpt.compute_adjoint_sources","page":"Types","title":"DistributedEmitterOpt.compute_adjoint_sources","text":"compute_adjoint_sources(obj::SERSObjective, pde, fields, pt, sim) → Dict{CacheKey, Vector}\n\nCompute adjoint RHS vectors ∂g/∂E for each field. Sums contributions over all input/output combinations with weights.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#DistributedEmitterOpt.explicit_sensitivity","page":"Types","title":"DistributedEmitterOpt.explicit_sensitivity","text":"Default: no explicit sensitivity term.\n\n\n\n\n\nexplicit_sensitivity(obj::SERSObjective, pde, fields, pf, pt, sim, control; space=sim.Pf) → Vector\n\nExplicit ∂g/∂pf term from objective's direct dependence on pt. Sums contributions over all input/output combinations with weights.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#DistributedEmitterOpt.OptimizationProblem","page":"Types","title":"DistributedEmitterOpt.OptimizationProblem","text":"OptimizationProblem\n\nMain container for topology optimization. Holds the PDE config, objective, FEM infrastructure, solver caches, and current optimization state.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#DistributedEmitterOpt.init_uniform!","page":"Types","title":"DistributedEmitterOpt.init_uniform!","text":"Set all design parameters to value.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#DistributedEmitterOpt.init_random!","page":"Types","title":"DistributedEmitterOpt.init_random!","text":"Randomize design parameters using legacy initialization behavior.\n\nLegacy rand init used a filtered random field with fixed radius 20 nm:\n\nFoundry mode: conic filter + sharp tanh projection (β=1028, η=0.5)\n3D mode: Helmholtz filter solve only\n\n\n\n\n\n","category":"function"},{"location":"api/types/#DistributedEmitterOpt.init_from_file!","page":"Types","title":"DistributedEmitterOpt.init_from_file!","text":"Load design parameters from a file.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#DistributedEmitterOpt.Simulation","page":"Types","title":"DistributedEmitterOpt.Simulation","text":"Simulation\n\nContainer for all FEM infrastructure: discrete model, function spaces, integration measures, and FoundryGrid for 2D DOF mode.\n\nFE Spaces\n\nV, U — Nédélec spaces for E-field\nP — Piecewise constant (raw design on mesh)\nPf — Continuous Lagrange (filtered design)\n\nIntegration Measures\n\ndΩ — Full domain\ndΩ_design — Design region\ndΩ_raman — Raman/target region\ndS_top, dS_bottom — ABC boundaries\ndΓ_source — Source plane\n\n\n\n\n\n","category":"type"},{"location":"api/types/#DistributedEmitterOpt.build_simulation","page":"Types","title":"DistributedEmitterOpt.build_simulation","text":"build_simulation(meshfile; kwargs...) -> Simulation\n\nBuild Simulation from mesh file.\n\nArguments\n\nmeshfile — Path to .msh file\norder — Nédélec element order (default 0)\ndegree — Quadrature degree (default 6)\ndir_x, dir_y — Dirichlet boundaries for PEC symmetry\nsource_y — Source polarization (true=y, false=x)\nfoundry_mode — Use 2D DOF grid\nsizes — Manual (xlo, xhi, ylo, yhi, zlo, zhi) for grid\n\n\n\n\n\n","category":"function"},{"location":"api/types/#DistributedEmitterOpt.SimulationBundle","page":"Types","title":"DistributedEmitterOpt.SimulationBundle","text":"SimulationBundle\n\nContainer for multiple Simulation objects (per polarization), sharing the same underlying discrete model.\n\nFields\n\ndefault::Simulation: The primary simulation (usually y-polarized)\nby_pol::Dict{Symbol,Simulation}: Sims keyed by polarization (:x, :y)\n\n\n\n\n\n","category":"type"},{"location":"api/types/#DistributedEmitterOpt.build_simulation_bundle","page":"Types","title":"DistributedEmitterOpt.build_simulation_bundle","text":"build_simulation_bundle(meshfile; per_x=false, per_y=false, kwargs...)\n\nBuild a polarization-aware SimulationBundle with shared discrete model.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#DistributedEmitterOpt.default_sim","page":"Types","title":"DistributedEmitterOpt.default_sim","text":"default_sim(sim_or_bundle)\n\nGet the default Simulation from a Simulation or SimulationBundle.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#DistributedEmitterOpt.sim_for","page":"Types","title":"DistributedEmitterOpt.sim_for","text":"sim_for(sim_or_bundle, fc::FieldConfig)\n\nGet the appropriate Simulation for a given FieldConfig (based on polarization).\n\n\n\n\n\n","category":"function"},{"location":"api/types/#DistributedEmitterOpt.AbstractSolver","page":"Types","title":"DistributedEmitterOpt.AbstractSolver","text":"AbstractSolver\n\nInterface for sparse direct solvers. Concrete implementations wrap Pardiso, UMFPACK, etc.\n\nRequired interface\n\nlu!(cache, A) — Factorize matrix A\nsolve!(cache, b) — Solve Ax = b (forward)\nsolve_adjoint!(cache, b) — Solve A'x = b (adjoint)\n\n\n\n\n\n","category":"type"},{"location":"api/types/#DistributedEmitterOpt.UmfpackSolver","page":"Types","title":"DistributedEmitterOpt.UmfpackSolver","text":"UMFPACK-based solver.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#DistributedEmitterOpt.SolverCache","page":"Types","title":"DistributedEmitterOpt.SolverCache","text":"SolverCache{S<:AbstractSolver}\n\nCaches LU factorizations for reuse across optimization iterations. Separate caches for:\n\nMaxwell system (complex, A_factor)\nEigen shift system (complex, Afactor in eigencache)\nFilter PDE (real, F_factor)\n\nFields\n\nA_factor — Maxwell LU factorization\nF_factor — Filter Helmholtz LU factorization\nE2_factor — E² regularization LU factorization (optional)\nx — Solution vector cache\nam_head — True if this process performs solves (MPI compatibility)\nsolver — Solver backend\n\n\n\n\n\n","category":"type"},{"location":"api/types/#DistributedEmitterOpt.SolverCachePool","page":"Types","title":"DistributedEmitterOpt.SolverCachePool","text":"SolverCachePool{S<:AbstractSolver}\n\nPool of solver caches, one per unique (λ, θ, polarization) configuration. Deduplicates caches so identical configs share the same LU factorization.\n\nAlso holds a shared filter cache and a shared eigen cache for shift-invert solves.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#DistributedEmitterOpt.SolverPoolBundle","page":"Types","title":"DistributedEmitterOpt.SolverPoolBundle","text":"SolverPoolBundle\n\nContainer for multiple SolverCachePool objects (per polarization), corresponding to the Simulation objects in a bundle.\n\nFields\n\ndefault::SolverCachePool: The primary pool\nby_pol::Dict{Symbol,SolverCachePool}: Pools keyed by polarization (:x, :y)\n\n\n\n\n\n","category":"type"},{"location":"api/types/#DistributedEmitterOpt.get_cache!","page":"Types","title":"DistributedEmitterOpt.get_cache!","text":"Get or create cache for a field config.\n\n\n\n\n\nGet cache by key directly.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#DistributedEmitterOpt.clear_maxwell_factors!","page":"Types","title":"DistributedEmitterOpt.clear_maxwell_factors!","text":"Clear all Maxwell factorizations (call when pt changes).\n\n\n\n\n\nclear_maxwell_factors!(pool)\n\nClear LU factors for single or bundled pools.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#DistributedEmitterOpt.default_pool","page":"Types","title":"DistributedEmitterOpt.default_pool","text":"default_pool(pool_or_bundle)\n\nGet the default SolverCachePool from a pool or bundle.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#DistributedEmitterOpt.pool_for","page":"Types","title":"DistributedEmitterOpt.pool_for","text":"pool_for(pool_or_bundle, fc::FieldConfig)\n\nGet the appropriate SolverCachePool for a given FieldConfig.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#DistributedEmitterOpt.FoundryGrid","page":"Types","title":"DistributedEmitterOpt.FoundryGrid","text":"FoundryGrid\n\n2D rectilinear grid for lithography-compatible topology optimization. Design parameters live on a regular (x, y) grid and are interpolated to the 3D FEM mesh via bilinear interpolation.\n\nFields\n\nx — Grid x-coordinates (monotonic)\ny — Grid y-coordinates (monotonic)\nparams — Design parameter matrix (nx × ny)\nnodes — Mesh node coordinates for interpolation/adjoint mapping\nadj_idx — Cached grid indices for adjoint scatter (4 × nnodes)\nadj_w — Cached weights for adjoint scatter (4 × nnodes)\nadj_ready — Whether adjoint cache is initialized\n\n\n\n\n\n","category":"type"},{"location":"api/types/#DistributedEmitterOpt.getgrid","page":"Types","title":"DistributedEmitterOpt.getgrid","text":"getgrid(labels, Ω, np, nodes; sizes=nothing) -> FoundryGrid\n\nBuild a FoundryGrid from mesh topology. The grid covers the x-y extent of the design region with approximately √np points per side.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#DistributedEmitterOpt.pf_grid","page":"Types","title":"DistributedEmitterOpt.pf_grid","text":"pf_grid(r, params, gridx, gridy) -> Real\n\nBilinear interpolation of grid parameters at point r = (x, y, z).\n\n\n\n\n\nConvenience method using FoundryGrid.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#DistributedEmitterOpt.Control","page":"Types","title":"DistributedEmitterOpt.Control","text":"Control\n\nHyperparameters for the topology optimization pipeline: filtering, projection, and linewidth constraints.\n\nFiltering\n\nuse_filter — Enable filtering step\nR_filter — Filter radius (rx, ry, rz) in nm\nuse_dct — Use DCT convolution (true) or Helmholtz PDE (false)\n\nProjection / SSP\n\nSSP on the FEM mesh is always used (pf → pt).\nβ — Projection steepness (higher = sharper, use continuation)\nη — Threshold point (typically 0.5)\nR_ssp — SSP smoothing radius\n\nLinewidth Constraints\n\nuse_constraints — Enable erosion/dilation constraints\nη_erosion — Erosion threshold (typically 0.75)\nη_dilation — Dilation threshold (typically 0.25)\nb1 — Constraint tolerance\nc0 — Indicator function steepness\n\n\n\n\n\n","category":"type"},{"location":"api/types/#DistributedEmitterOpt.tanh_projection","page":"Types","title":"DistributedEmitterOpt.tanh_projection","text":"tanh_projection(x, η, β) -> Real\n\nHeaviside-ish projection: smooth step from 0 to 1 centered at η. As β → ∞, approaches true Heaviside function.\n\n\n\n\n\nVectorized tanh projection for arrays.\n\n\n\n\n\nConvenience with Control struct.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#DistributedEmitterOpt.Threshold","page":"Types","title":"DistributedEmitterOpt.Threshold","text":"Threshold(pf; control) -> Real\n\nTanh projection for lazy composition with Gridap's ∘ operator. This is the function form used in ComposedFunctions.\n\nReference: Old codebase Controls.jl:Threshold\n\n\n\n\n\n","category":"function"},{"location":"api/topologyopt/#TopologyOpt","page":"TopologyOpt","title":"TopologyOpt","text":"Filtering, projection, and constraint functions for topology optimization.","category":"section"},{"location":"api/topologyopt/#Material-Interpolation","page":"TopologyOpt","title":"Material Interpolation","text":"","category":"section"},{"location":"api/topologyopt/#Filtering-(2D-Grid)","page":"TopologyOpt","title":"Filtering (2D Grid)","text":"","category":"section"},{"location":"api/topologyopt/#Filtering-(3D-Helmholtz)","page":"TopologyOpt","title":"Filtering (3D Helmholtz)","text":"","category":"section"},{"location":"api/topologyopt/#Projection","page":"TopologyOpt","title":"Projection","text":"","category":"section"},{"location":"api/topologyopt/#Constraints","page":"TopologyOpt","title":"Constraints","text":"","category":"section"},{"location":"api/topologyopt/#DistributedEmitterOpt.christiansen_ε","page":"TopologyOpt","title":"DistributedEmitterOpt.christiansen_ε","text":"christiansen_ε(p, nf, nm) -> Complex\n\nChristiansen refractive index interpolation:   n(p) = nf + (nm - nf) * p   ε(p) = n(p)²\n\nThis gives:   p=0 → ε = nf² (fluid)   p=1 → ε = nm² (metal)\n\n\n\n\n\n","category":"function"},{"location":"api/topologyopt/#DistributedEmitterOpt.∂christiansen_ε","page":"TopologyOpt","title":"DistributedEmitterOpt.∂christiansen_ε","text":"Derivative: ∂ε/∂p = 2n(p)(nm - nf)\n\n\n\n\n\n","category":"function"},{"location":"api/topologyopt/#DistributedEmitterOpt.filter_grid","page":"TopologyOpt","title":"DistributedEmitterOpt.filter_grid","text":"filter_grid(p_vec, sim, control) -> Vector\n\nFilter design vector using 2D convolution.\n\nArguments\n\np_vec — Flat design vector\nsim — Simulation (for grid dimensions)\ncontrol — Control (for filter params)\n\n\n\n\n\n","category":"function"},{"location":"api/topologyopt/#DistributedEmitterOpt.filter_grid_adjoint","page":"TopologyOpt","title":"DistributedEmitterOpt.filter_grid_adjoint","text":"filter_grid_adjoint(∂g_∂pf, sim, control) -> Vector\n\nAdjoint of filter operation (same as forward for symmetric kernel).\n\n\n\n\n\n","category":"function"},{"location":"api/topologyopt/#DistributedEmitterOpt.filter_helmholtz!","page":"TopologyOpt","title":"DistributedEmitterOpt.filter_helmholtz!","text":"filter_helmholtz!(p_vec, cache, sim, control) -> Vector\n\nFilter design using Helmholtz PDE (3D DOF mode). Caches factorization in cache.F_factor.\n\n\n\n\n\n","category":"function"},{"location":"api/topologyopt/#DistributedEmitterOpt.filter_helmholtz_adjoint!","page":"TopologyOpt","title":"DistributedEmitterOpt.filter_helmholtz_adjoint!","text":"filter_helmholtz_adjoint!(∂g_∂pf, cache, sim, control) -> Vector\n\nAdjoint of Helmholtz filter. Since A is symmetric: A^(-T) = A^(-1), so adjoint solve = forward solve.\n\n\n\n\n\n","category":"function"},{"location":"api/topologyopt/#DistributedEmitterOpt.project_grid","page":"TopologyOpt","title":"DistributedEmitterOpt.project_grid","text":"project_grid(pf_vec, sim, control) -> Vector\n\nProject filtered design to binary-ish values (2D DOF mode).\n\n\n\n\n\n","category":"function"},{"location":"api/topologyopt/#DistributedEmitterOpt.project_grid_adjoint","page":"TopologyOpt","title":"DistributedEmitterOpt.project_grid_adjoint","text":"project_grid_adjoint(∂g_∂pt, pf_vec, control) -> Vector\n\nAdjoint of projection: chain rule through tanh.\n\n\n\n\n\n","category":"function"},{"location":"api/topologyopt/#DistributedEmitterOpt.project_fe","page":"TopologyOpt","title":"DistributedEmitterOpt.project_fe","text":"project_fe(pf_vec, sim, control) -> ComposedFunction\n\nConvenience wrapper: build FEFunction from vector and apply SSP projection.\n\n\n\n\n\n","category":"function"},{"location":"api/topologyopt/#DistributedEmitterOpt.project_ssp","page":"TopologyOpt","title":"DistributedEmitterOpt.project_ssp","text":"project_ssp(pf, control) -> ComposedFunction\n\nSubpixel-smoothed projection on the FEM mesh (SSP is ALWAYS used). Returns a ComposedFunction for lazy evaluation in Gridap.\n\n\n\n\n\n","category":"function"},{"location":"api/topologyopt/#DistributedEmitterOpt.glc_solid","page":"TopologyOpt","title":"DistributedEmitterOpt.glc_solid","text":"glc_solid(x, grad; sim, control) -> Float64\n\nSolid linewidth constraint for NLopt. Constraint satisfied when ≤ 0.\n\n\n\n\n\n","category":"function"},{"location":"api/topologyopt/#DistributedEmitterOpt.glc_void","page":"TopologyOpt","title":"DistributedEmitterOpt.glc_void","text":"glc_void(x, grad; sim, control) -> Float64\n\nVoid linewidth constraint for NLopt.\n\n\n\n\n\n","category":"function"},{"location":"api/topologyopt/#DistributedEmitterOpt.glc_solid_fe","page":"TopologyOpt","title":"DistributedEmitterOpt.glc_solid_fe","text":"glc_solid_fe(p_vec, grad, obj) -> Float64\n\nSolid linewidth constraint for NLopt (3D DOF mode).\n\n\n\n\n\n","category":"function"},{"location":"api/topologyopt/#DistributedEmitterOpt.glc_void_fe","page":"TopologyOpt","title":"DistributedEmitterOpt.glc_void_fe","text":"glc_void_fe(p_vec, grad, obj) -> Float64\n\nVoid linewidth constraint for NLopt (3D DOF mode).\n\n\n\n\n\n","category":"function"},{"location":"examples/anisotropic_3d_inelastic_optimization/#Anisotropic-3D-Inelastic:-Mini-Optimization","page":"Anisotropic 3D Inelastic Optimization","title":"Anisotropic 3D Inelastic: Mini Optimization","text":"\n\n@meta EditURL = \"https://github.com/ianmatthewhammond/DistributedEmitterOpt.jl/tree/main/docs/src/examples/anisotropic3dinelastic_optimization.jl\"\n\n\n\n3D DOF example with anisotropic polarizability and inelastic scattering. We use two emission outputs at the same wavelength but different polarizations.\n\nusing DistributedEmitterOpt\nusing LinearAlgebra","category":"section"},{"location":"examples/anisotropic_3d_inelastic_optimization/#1.-Mesh-generation","page":"Anisotropic 3D Inelastic Optimization","title":"1. Mesh generation","text":"λ_pump = 532.0\nλ_emission = 600.0\n\ngeo = SymmetricGeometry(λ_pump; L=100.0, W=100.0, hd=80.0, hsub=40.0)\ngeo.l1 = 50.0\ngeo.l2 = 30.0\ngeo.l3 = 50.0\ngeo.hair = 200.0\ngeo.hs = 120.0\ngeo.ht = 80.0\n\noutdir = mktempdir()\nmeshfile = joinpath(outdir, \"mesh.msh\")\ngenmesh(geo, meshfile; per_x=false, per_y=false)","category":"section"},{"location":"examples/anisotropic_3d_inelastic_optimization/#2.-Physics-(inelastic-with-two-outputs,-mixed-polarization)","page":"Anisotropic 3D Inelastic Optimization","title":"2. Physics (inelastic with two outputs, mixed polarization)","text":"env = Environment(mat_design=\"Ag\", mat_substrate=\"Ag\", mat_fluid=1.33)\ninputs = [FieldConfig(λ_pump; θ=0.0, pol=:y)]\noutputs = [\n    FieldConfig(λ_emission; θ=0.0, pol=:y, weight=1.0),\n    FieldConfig(λ_emission; θ=0.0, pol=:x, weight=0.7)\n]\n\npde = MaxwellProblem(env=env, inputs=inputs, outputs=outputs)","category":"section"},{"location":"examples/anisotropic_3d_inelastic_optimization/#3.-Objective-(anisotropic)","page":"Anisotropic 3D Inelastic Optimization","title":"3. Objective (anisotropic)","text":"function anisotropic_tensor()\n    α = ComplexF64[\n        1.10+0.00im 0.05+0.02im 0.01-0.03im\n        0.02-0.01im 0.95+0.00im 0.03+0.04im\n        0.01+0.00im 0.02-0.02im 1.05+0.00im\n    ]\n    return (α + transpose(α)) / 2\nend\n\nobjective = SERSObjective(\n    αₚ=anisotropic_tensor(),\n    volume=true,\n    surface=false,\n    use_damage_model=false\n)","category":"section"},{"location":"examples/anisotropic_3d_inelastic_optimization/#4.-Controls","page":"Anisotropic 3D Inelastic Optimization","title":"4. Controls","text":"control = Control(\n    use_filter=true,\n    R_filter=(20.0, 20.0, 20.0),\n    use_dct=false,  # Helmholtz filter in 3D\n    use_projection=true,\n    β=8.0,\n    η=0.5,\n    use_ssp=true\n)","category":"section"},{"location":"examples/anisotropic_3d_inelastic_optimization/#5.-Problem-assembly","page":"Anisotropic 3D Inelastic Optimization","title":"5. Problem assembly","text":"The meshfile-based constructor automatically creates a SimulationBundle that handles both x and y polarization for mixed-polarization problems.\n\nprob = OptimizationProblem(pde, objective, meshfile, UmfpackSolver();\n    per_x=false,\n    per_y=false,\n    foundry_mode=false,\n    control=control,\n    root=outdir\n)\n\ninit_uniform!(prob, 0.5)","category":"section"},{"location":"examples/anisotropic_3d_inelastic_optimization/#6.-Mini-optimization-(short-run)","page":"Anisotropic 3D Inelastic Optimization","title":"6. Mini optimization (short run)","text":"Keep this tiny for demonstration; increase for real runs.\n\nβ_schedule = [8.0, 16.0]\nmax_iter = 5\n\n(g_opt, p_opt) = optimize!(prob; max_iter=max_iter, β_schedule=β_schedule)\n\nprintln(\"Final objective = \", g_opt)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"architecture/#Architecture","page":"Architecture","title":"Architecture","text":"How the types and data flow are organized.","category":"section"},{"location":"architecture/#Types","page":"Architecture","title":"Types","text":"","category":"section"},{"location":"architecture/#MaxwellProblem","page":"Architecture","title":"MaxwellProblem","text":"Specifies the physics: which PDEs to solve.\n\nstruct MaxwellProblem\n    env::Environment              # materials\n    inputs::Vector{FieldConfig}   # pump wavelengths\n    outputs::Vector{FieldConfig}  # emission wavelengths (or same as inputs)\n    α_loss::Float64               # absorption weighting\nend\n\nEnvironment holds material properties:\n\nEnvironment(mat_design=\"Ag\", mat_substrate=\"Ag\", mat_fluid=1.33)\n\nFieldConfig describes a single solve:\n\nFieldConfig(λ=532.0, θ=0.0, pol=:y, weight=1.0)","category":"section"},{"location":"architecture/#ObjectiveFunction","page":"Architecture","title":"ObjectiveFunction","text":"Abstract type. Implementations must provide three methods:\n\ncompute_objective(obj, pde, fields, pt, sim)          # g(E)\ncompute_adjoint_sources(obj, pde, fields, pt, sim)    # dg/dE\nexplicit_sensitivity(obj, pde, fields, pf, pt, sim, control)  # dg/dpf\n\nSERSObjective implements this for the SO(3)-averaged trace formula:\n\nSERSObjective(αp=I(3), volume=true, surface=false, use_damage_model=false)","category":"section"},{"location":"architecture/#OptimizationProblem","page":"Architecture","title":"OptimizationProblem","text":"Ties everything together:\n\nmutable struct OptimizationProblem{PDE,Obj}\n    pde::MaxwellProblem\n    objective::ObjectiveFunction\n    sim::Simulation\n    foundry_mode::Bool\n    pool::SolverCachePool\n    control::Control\n    p::Vector{Float64}      # design parameters\n    g::Float64              # current objective\n    grad::Vector{Float64}   # current gradient\nend","category":"section"},{"location":"architecture/#Optimization-flow","page":"Architecture","title":"Optimization flow","text":"p (design params)\n    |\n    v  filter_grid (foundry) / filter_helmholtz! (3D)\npf (filtered)\n    |\n    v  interpolate grid->mesh (foundry only)\n    v  project_ssp\npt (projected, near-binary)\n    |\n    v  solve_forward! (Maxwell for each FieldConfig)\nE_fields\n    |\n    |-->  compute_objective -> g\n    |\n    v  compute_adjoint_sources -> b_adj\n    |\n    v  solve_adjoint! (reuses the LU factors)\nlambda_fields\n    |\n    v  pde_sensitivity + explicit_sensitivity\ndg/dpf\n    |\n    v  filter_adjoint\ndg/dp (gradient)","category":"section"},{"location":"architecture/#Key-functions","page":"Architecture","title":"Key functions","text":"Function What it does\nsolve_forward!(pde, pt, sim, pool) Solve Maxwell for all FieldConfigs\nsolve_adjoint!(pde, sources, sim, pool) Reuse LU factors for the adjoint\npde_sensitivity(...) Material derivative lambda^T dA/dp E\nobjective_and_gradient!(grad, p, prob) Main entry point\noptimize!(prob) NLopt with beta-continuation","category":"section"},{"location":"architecture/#Writing-a-new-objective","page":"Architecture","title":"Writing a new objective","text":"Create Objectives/MyObjective.jl:\n\nstruct MyObjective <: ObjectiveFunction\n    # params\nend\n\ncompute_objective(obj::MyObjective, pde, fields, pt, sim) = ...\ncompute_adjoint_sources(obj::MyObjective, pde, fields, pt, sim) = ...\nexplicit_sensitivity(obj::MyObjective, pde, fields, pf, pt, sim, control) = ...\n\nInclude it in DistributedEmitterOpt.jl and export.\nUse it:\n\nprob = OptimizationProblem(pde, MyObjective(...), sim, solver)","category":"section"},{"location":"architecture/#File-organization","page":"Architecture","title":"File organization","text":"Directory What's in it\nTypes/ FieldConfig, Environment, MaxwellProblem, OptimizationProblem, Control, Simulation, SolverCache\nPhysics/ Maxwell assembly, SERS utilities, MaxwellSolver\nObjectives/ SERSObjective\nTopologyOpt/ Filtering (Helmholtz, grid), SSP projection\nOptimization/ Optimizer (NLopt), GradientCoordinator\nSolvers/ UmfpackSolver (LU wrapper)","category":"section"},{"location":"api/optimization/#Optimization","page":"Optimization","title":"Optimization","text":"High-level optimization interface and gradient computation.","category":"section"},{"location":"api/optimization/#Main-Interface","page":"Optimization","title":"Main Interface","text":"","category":"section"},{"location":"api/optimization/#Utilities","page":"Optimization","title":"Utilities","text":"","category":"section"},{"location":"api/optimization/#DistributedEmitterOpt.optimize!","page":"Optimization","title":"DistributedEmitterOpt.optimize!","text":"optimize!(prob; kwargs...) -> (g_opt, p_opt)\n\nRun topology optimization with beta-continuation.\n\nKeyword arguments:\n\nmax_iter – iterations per beta value (default 40)\nβ_schedule – projection steepness values to sweep\nα_schedule – optional loss schedule (same length as beta_schedule)\nuse_constraints – enable linewidth constraints on the final beta epoch only\ntol – relative tolerance for convergence\nbackup – enable autosaving (p, g_history) checkpoints\nbackup_every – autosave interval (iterations)\nbackup_path – optional checkpoint path (default joinpath(prob.root, \"results_backup.jld2\"))\nresume_from – optional checkpoint path to resume from\n\n\n\n\n\noptimize!(prob::EigenOptimizationProblem; kwargs...) -> (g_opt, p_opt)\n\nRun eigenvalue-based optimization with beta-continuation. Note: eigen sensitivities are TODO and will error during gradient evaluation.\n\n\n\n\n\n","category":"function"},{"location":"api/optimization/#DistributedEmitterOpt.objective_and_gradient!","page":"Optimization","title":"DistributedEmitterOpt.objective_and_gradient!","text":"objective_and_gradient!(grad, p, prob) -> Float64\n\nForward + adjoint pass. Main entry point for optimization.\n\n\n\n\n\n","category":"function"},{"location":"api/optimization/#DistributedEmitterOpt.evaluate","page":"Optimization","title":"DistributedEmitterOpt.evaluate","text":"Single evaluation (no optimization loop).\n\n\n\n\n\n","category":"function"},{"location":"api/optimization/#DistributedEmitterOpt.test_gradient","page":"Optimization","title":"DistributedEmitterOpt.test_gradient","text":"Finite-difference gradient check.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#Physics","page":"Physics","title":"Physics","text":"Maxwell equation assembly and material properties.","category":"section"},{"location":"api/physics/#Materials","page":"Physics","title":"Materials","text":"","category":"section"},{"location":"api/physics/#Maxwell-assembly","page":"Physics","title":"Maxwell assembly","text":"","category":"section"},{"location":"api/physics/#Maxwell-solver","page":"Physics","title":"Maxwell solver","text":"","category":"section"},{"location":"api/physics/#DistributedEmitterOpt.refindex","page":"Physics","title":"DistributedEmitterOpt.refindex","text":"refindex(material::String) -> (n_interp, k_interp)\n\nLoad refractive index data for a material and return interpolation functions. The interpolants are callable with wavelength in nm.\n\nExample\n\nn_Ag, k_Ag = refindex(\"Ag\")\nn_532 = n_Ag(532.0)  # Real part at 532 nm\nk_532 = k_Ag(532.0)  # Imaginary part\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#DistributedEmitterOpt.complex_index","page":"Physics","title":"DistributedEmitterOpt.complex_index","text":"complex_index(material::String, λ::Float64) -> ComplexF64\n\nGet complex refractive index n + ik at wavelength λ (nm).\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#DistributedEmitterOpt.resolve_index","page":"Physics","title":"DistributedEmitterOpt.resolve_index","text":"resolve_index(mat::MaterialSpec, λ::Float64) → ComplexF64\n\nGet complex refractive index at wavelength λ (nm).\n\nString: lookup from material database\nFloat64: use directly as real index\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#DistributedEmitterOpt.plasmon_period","page":"Physics","title":"DistributedEmitterOpt.plasmon_period","text":"plasmon_period(n_fluid, n_metal, λ) -> Float64\n\nEstimate surface plasmon polariton wavelength: λ_spp = λ / Re(√(εm·εf / (εm + εf)))\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#DistributedEmitterOpt.PhysicalParams","page":"Physics","title":"DistributedEmitterOpt.PhysicalParams","text":"PhysicalParams\n\nPhysical parameters for a single frequency solve.\n\n\n\n\n\n","category":"type"},{"location":"api/physics/#DistributedEmitterOpt.assemble_maxwell","page":"Physics","title":"DistributedEmitterOpt.assemble_maxwell","text":"assemble_maxwell(pt, sim, phys) -> SparseMatrix\n\nAssemble Maxwell curl-curl matrix with Sommerfeld ABC.\n\nA = ∫ (∇×v)·(∇×u) dΩ - k²∫ ε(p)v·u dΩ + ik√ε ∫ v·u dS (ABC)\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#DistributedEmitterOpt.assemble_source","page":"Physics","title":"DistributedEmitterOpt.assemble_source","text":"assemble_source(sim, phys; source_y=true) -> Vector\n\nAssemble source vector for plane wave incidence.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#DistributedEmitterOpt.solve_forward!","page":"Physics","title":"DistributedEmitterOpt.solve_forward!","text":"solve_forward!(pde, pt, sim, pool) -> Dict{CacheKey, CellField}\n\nSolve Maxwell for every unique field configuration. Caches LU factorizations in the pool.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#DistributedEmitterOpt.solve_adjoint!","page":"Physics","title":"DistributedEmitterOpt.solve_adjoint!","text":"solve_adjoint!(pde, sources, sim, pool) -> Dict{CacheKey, CellField}\n\nSolve adjoint Maxwell for each adjoint source. Reuses the LU factors already in the pool.\n\n\n\n\n\nSolve A'x = b (adjoint system).\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#DistributedEmitterOpt.pde_sensitivity","page":"Physics","title":"DistributedEmitterOpt.pde_sensitivity","text":"pde_sensitivity(pde, fields, adjoints, pf, pt, sim, control; space=sim.Pf)\n\nCompute dg/dpf from the PDE term (lambda^T dA/dp E), summed over all field configs.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#DistributedEmitterOpt.build_phys_params","page":"Physics","title":"DistributedEmitterOpt.build_phys_params","text":"build_phys_params(fc, env, sim; α=0.0)\n\nBuild PhysicalParams for a given FieldConfig and Environment.\n\n\n\n\n\n","category":"function"},{"location":"#DistributedEmitterOpt.jl","page":"Home","title":"DistributedEmitterOpt.jl","text":"Topology optimization of nanophotonic structures for SERS enhancement, using adjoint sensitivity analysis with Gridap.jl finite elements.","category":"section"},{"location":"#What-it-does","page":"Home","title":"What it does","text":"Solves Maxwell's equations on a finite-element mesh and optimizes the material layout to maximize a SERS objective. Gradients come from the adjoint method. Beta-continuation pushes designs toward binary.\n\nSupports 2D foundry-mode DOFs (grid interpolated onto the mesh) and full 3D mesh DOFs.","category":"section"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"using DistributedEmitterOpt\n\n# 1. Define geometry and generate mesh\ngeo = SymmetricGeometry(532.0; L=200.0, W=200.0)\nmeshfile = \"design.msh\"\ngenmesh(geo, meshfile; per_x=false, per_y=false)\n\n# 2. Configure physics\nenv = Environment(mat_design=\"Ag\", mat_substrate=\"Ag\", mat_fluid=1.33)\npde = MaxwellProblem(\n    env = env,\n    inputs = [FieldConfig(532.0; θ=0.0, pol=:y)],\n    outputs = [FieldConfig(600.0; θ=0.0, pol=:y)]  # Inelastic\n)\n\n# 3. Build optimization problem (meshfile constructor)\nprob = OptimizationProblem(pde, SERSObjective(), meshfile, UmfpackSolver();\n    per_x = false,\n    per_y = false,\n    foundry_mode = true\n)\n\n# 4. Run optimization\ninit_uniform!(prob, 0.5)\ng_opt, p_opt = optimize!(prob; max_iter=100)","category":"section"},{"location":"#Key-concepts","page":"Home","title":"Key concepts","text":"","category":"section"},{"location":"#SimulationBundle","page":"Home","title":"SimulationBundle","text":"When you use the meshfile-based OptimizationProblem constructor, it internally creates a SimulationBundle — a collection of Simulation objects for different polarizations. This allows mixed-polarization optimization (e.g., pump at y-pol, emission at x-pol).\n\n# Meshfile constructor automatically creates SimulationBundle\nprob = OptimizationProblem(pde, objective, meshfile, solver; per_x, per_y, ...)\n\n# Access underlying simulation\nsim = default_sim(prob.sim)  # Gets the default (y-polarized) simulation","category":"section"},{"location":"#DOF-Modes","page":"Home","title":"DOF Modes","text":"Foundry mode (foundry_mode=true): Design DOFs live on a 2D grid, interpolated onto the 3D mesh. Faster, suitable for planar structures.\n3D FE mode (foundry_mode=false): Design DOFs are mesh elements directly. Full 3D topology optimization.","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\"architecture.md\", \"api/types.md\", \"api/physics.md\", \"api/objectives.md\", \"api/topologyopt.md\", \"api/optimization.md\"]\nDepth = 2","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"api/objectives/#Objectives","page":"Objectives","title":"Objectives","text":"Objective function implementations.","category":"section"},{"location":"api/objectives/#SERS-Objective","page":"Objectives","title":"SERS Objective","text":"SERS enhancement using the SO(3)-averaged trace formula.","category":"section"},{"location":"api/objectives/#SERS-internals","page":"Objectives","title":"SERS internals","text":"Helper functions live in src/Physics/SERS.jl and are not exported.","category":"section"},{"location":"api/objectives/#DistributedEmitterOpt.SERSObjective","page":"Objectives","title":"DistributedEmitterOpt.SERSObjective","text":"SERSObjective <: ObjectiveFunction\n\nSERS (Surface-Enhanced Raman Scattering) objective: maximize enhancement over molecular region using SO(3)-averaged trace formulation.\n\nFields\n\nαₚ — 3×3 Raman polarizability tensor\nuse_damage_model — Enable molecular quenching\nγ_damage — Damage model steepness\nE_threshold — Damage threshold field magnitude\nvolume — Integrate over fluid volume\nsurface — Integrate over metal-fluid interface\n\n\n\n\n\n","category":"type"},{"location":"examples/dielectric_2d_elastic_optimization/#Dielectric-2D-Foundry:-Elastic-Optimization","page":"Dielectric 2D Elastic Optimization","title":"Dielectric 2D Foundry: Elastic Optimization","text":"\n\n@meta EditURL = \"https://github.com/ianmatthewhammond/DistributedEmitterOpt.jl/tree/main/docs/src/examples/dielectric2delastic_optimization.jl\"\n\n\n\n2D DOF optimization with a dielectric design material (real refractive index).\n\nusing DistributedEmitterOpt\nusing LinearAlgebra","category":"section"},{"location":"examples/dielectric_2d_elastic_optimization/#1.-Mesh-simulation-(foundry-mode)","page":"Dielectric 2D Elastic Optimization","title":"1. Mesh + simulation (foundry mode)","text":"λ = 1550.0\ngeo = SymmetricGeometry(λ; L=300.0, W=300.0, hd=120.0, hsub=60.0)\ngeo.l1 = 60.0\ngeo.l2 = 30.0\ngeo.l3 = 60.0\n\noutdir = mktempdir()\nmeshfile = joinpath(outdir, \"mesh.msh\")\ngenmesh(geo, meshfile; per_x=true, per_y=true)\n\nsim = build_simulation(meshfile; foundry_mode=true, dir_x=false, dir_y=false)","category":"section"},{"location":"examples/dielectric_2d_elastic_optimization/#2.-Physics-(dielectric,-elastic)","page":"Dielectric 2D Elastic Optimization","title":"2. Physics (dielectric, elastic)","text":"Use real refractive indices for dielectrics.\n\nenv = Environment(mat_design=2.0, mat_substrate=1.45, mat_fluid=1.0)\ninputs = [FieldConfig(λ; θ=0.0, pol=:y)]\n\nEmpty outputs => elastic scattering\n\npde = MaxwellProblem(env=env, inputs=inputs, outputs=FieldConfig[])\n\nobjective = SERSObjective(\n    αₚ=Matrix{ComplexF64}(I, 3, 3),\n    volume=true,\n    surface=false,\n    use_damage_model=false\n)","category":"section"},{"location":"examples/dielectric_2d_elastic_optimization/#3.-Controls","page":"Dielectric 2D Elastic Optimization","title":"3. Controls","text":"control = Control(\n    use_filter=true,\n    R_filter=(25.0, 25.0, 25.0),\n    use_dct=true,\n    use_projection=true,\n    β=8.0,\n    η=0.5,\n    use_ssp=true\n)","category":"section"},{"location":"examples/dielectric_2d_elastic_optimization/#4.-Problem-assembly","page":"Dielectric 2D Elastic Optimization","title":"4. Problem assembly","text":"prob = OptimizationProblem(pde, objective, sim, UmfpackSolver();\n    foundry_mode=true,\n    control=control,\n    root=outdir\n)\n\ninit_uniform!(prob, 0.5)","category":"section"},{"location":"examples/dielectric_2d_elastic_optimization/#5.-Mini-optimization-(short-run)","page":"Dielectric 2D Elastic Optimization","title":"5. Mini optimization (short run)","text":"β_schedule = [8.0, 16.0]\nmax_iter = 5\n\n(g_opt, p_opt) = optimize!(prob; max_iter=max_iter, β_schedule=β_schedule)\n\nprintln(\"Final objective = \", g_opt)\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
